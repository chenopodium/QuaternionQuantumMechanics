//
//HLSL shader code for a spinor generated by SpinLab, www.chavascience.com/spinlab
//Code property of ChavaEnergy.
//Code may be referenced or published with the following credit: HLSL shader code for a spinor generated by SpinLab, www.chavascience.com/spinlab
//
//
//Using modified Bra-Ket notation the shader impliments...
//HLSL code for spinor <x>

///////////////////////////  parameters and declarations  ///////////////////////////
#define pi 3.1414592654

float4x4 WorldXf : World;						// transform object vertices to world-space:
float4x4 WorldITXf : WorldInverseTranspose;		// transform object normals, tangents, & binormals to world-space:
float4x4 VpXf : WorldViewProjection;			// transform object vertices to view space and project them in perspective:
float4x4 ViewIXf : ViewInverse;					// provide tranform from "view" or "eye" coords back to world-space:
float4x4 ViewXf : View;				

float opacity = 1;

float Timer;
float Radius = 100.0f;
float ParticleSize = 1;
float Power = 2.0;
float Center = 40.0;
float spinorSpanX1 = 1;
float spinorSpanX2 = 1;
float spinorSpanX3 = 1;
float spinorSpanY1 = 1;
float spinorSpanY2 = 1;
float spinorSpanY3 = 1;
float braketFrequency = 1;
float kernelFrequency = 1;
float kernelPhase = 0;

static const float4 worldUp = {0,0,1,1};

struct VS_IN
{
	float4 Position : POSITION;
	float4 Normal : NORMAL;
	float2 UV : TEXCOORD;
	float4 Color : COLOR;
};

struct PS_IN
{
	float4 Position : SV_POSITION;
	float4 Normal : NORMAL;
	float2 UV : TEXCOORD;
	float4 Color : COLOR;
};

/////////////////////////// functions ///////////////////////////

float4x4 RotMatX(float x)
{
	float c=cos(x);
	float s=sin(x);

	float4x4 OUT = {
	{1,		0,		0,		0},
	{0,		c,		s,		0},
	{0,		-s,		c,		0},
	{0,		0,		0,		1}};
	return OUT;
};

float4x4 RotMatY(float x)
{
	float c=cos(x);
	float s=sin(x);

	float4x4 OUT = {
	{c,		0,		s,		0},
	{0,		1,		0,		0},
	{-s,	0,		c,		0},
	{0,		0,		0,		1}};
	return OUT;
};
float4x4 RotMatZ(float x)
{
	float c=cos(x);
	float s=sin(x);

	float4x4 OUT = {
	{c,		s,		0,		0},
	{-s,	c,		0,		0},
	{0,		0,		1,		0},
	{0,		0,		0,		1}};
	return OUT;
};

float4 PerformBillboard(float4 Pw, float2 uvoffset)
{	
	float3 eyeVector = VpXf._m02_m12_m22;
	
	float3 finalPos = Pw.xyz;
	float3 side;
	float3 up;
	
	side = normalize(cross(eyeVector,worldUp.xyz)).xyz;
	up = normalize(cross(side,eyeVector));
	
	finalPos += (uvoffset.x) * side * ParticleSize;
	finalPos += (-uvoffset.y) * up * ParticleSize;
	
	float4 finalPos4 = float4(finalPos,1);
	
	return finalPos4;
}

//VERTEX SHADERS

PS_IN VS_P( VS_IN input )		//Particles
{
	PS_IN output = (PS_IN)0;
	
	output.UV = input.UV;
	output.Color = input.Color;
	output.Normal = input.Normal;
	
	float4 Po = input.Position;
	float4 Pw = mul(Po, WorldXf);
	
	//float r = 1-length(Pw)/Radius;  //0<r<1     // radius and center scaling
	//r=saturate(pow(abs(r),Power)*Center);

	float r = (length( Pw ) - Center) / (Radius - Center);  //0<r<1     // radius and center scaling
	r = 1-r;
	r = saturate(pow(abs(r), Power));

	float4x4 rz, rzn;
	float4x4 rx1, rx2, rx3, ry1, ry2, ry3;
	float time, b;

	b = Timer + input.Normal.x;    // delta time for 3D trails packed into Normal.x  

	rz = RotMatZ(b);			//Bra function
	rzn = transpose(rz);		//Ket function

	rx1 = RotMatX(r * pi * spinorSpanX1);
	ry1 = RotMatY(r * pi * spinorSpanY1);
	rx2 = RotMatX(r * pi * spinorSpanX2);
	ry2 = RotMatY(r * pi * spinorSpanY2);
	rx3 = RotMatX(r * pi * spinorSpanX3);
	ry3 = RotMatY(r * pi * spinorSpanY3);
	
	float4x4 Rotation = {
	{1,		0,		0,		0},
	{0,		1,		0,		0},
	{0,		0,		1,		0},
	{0,		0,		0,		1}};

	//GENERATED LINES

Rotation = mul(Rotation, rz);
Rotation = mul(Rotation, rx1);
Rotation = mul(Rotation, rzn);

	/////////////////////////// output stage		
	Pw = mul(Pw, Rotation);
	
	Pw = PerformBillboard(Pw, input.UV);	
	output.Position = mul(Pw, VpXf);
	return output;
}

PS_IN VS_T( VS_IN input )		//Particles
{
	PS_IN output = (PS_IN)0;
	
	output.UV = input.UV;
	float4 colour = input.Color;
	output.Normal = input.Normal;
	
	float4 Po = input.Position;
	float4 Pw = mul(Po, WorldXf);
	
	//float r = 1-length(Pw)/Radius;  //0<r<1     // radius and center scaling
	//r=saturate(pow(abs(r),Power)*Center);

	float r = (length( Pw ) - Center) / (Radius - Center);  //0<r<1     // radius and center scaling
	r = 1-r;
	r = saturate(pow(abs(r), Power));

	float4x4 rz, rzn;
	float4x4 rx1, rx2, rx3, ry1, ry2, ry3;
	float time, b;

	b = Timer + input.Normal.x;    // delta time for 3D trails packed into Normal.x  

		rz = RotMatZ(b);			//Bra function
	rzn = transpose(rz);		//Ket function

	rx1 = RotMatX(r * pi * spinorSpanX1);
	ry1 = RotMatY(r * pi * spinorSpanY1);
	rx2 = RotMatX(r * pi * spinorSpanX2);
	ry2 = RotMatY(r * pi * spinorSpanY2);
	rx3 = RotMatX(r * pi * spinorSpanX3);
	ry3 = RotMatY(r * pi * spinorSpanY3);
	
	float4x4 Rotation = {
	{1,		0,		0,		0},
	{0,		1,		0,		0},
	{0,		0,		1,		0},
	{0,		0,		0,		1}};

	//GENERATED LINES

Rotation = mul(Rotation, rz);
Rotation = mul(Rotation, rx1);
Rotation = mul(Rotation, rzn);
	/////////////////////////// Field specific code
	b = Timer;
	float4x4 rzb = RotMatZ(b);
	rzn = transpose(rzb);
	
	float4x4 rf = {
		{1,		0,		0,		0},
		{0,		1,		0,		0},
		{0,		0,		1,		0},
		{0,		0,		0,		1}};	//Initialising to identity matrix

	//GENERATED CODE
	
	rf = mul(rf, rzb);
rf = mul(rf, rx1);
rf = mul(rf, rzn);

	rf = transpose(rf);
	Rotation = mul(Rotation, rf);
	
	float c = input.Normal.x / input.Normal.y;  //maximum trail length packed into Normal.y
	colour.r = c;
	colour.g = 1 - c;
	colour.b = 0;
	output.Color = colour;


	/////////////////////////// output stage		
	Pw = mul(Pw, Rotation);
	
	Pw = PerformBillboard(Pw, input.UV);	
	output.Position = mul(Pw, VpXf);
	return output;
}

PS_IN VS_G( VS_IN input )		//Geometry
{
	PS_IN output = (PS_IN)0;
	
	output.UV = input.UV;
	output.Color = input.Color;
	float4 Normal = mul(input.Normal, WorldITXf);
	
	float4 Po = input.Position;
	float4 Pw = mul(Po, WorldXf);
	
	//float r = 1 - length( Pw ) / Radius;  //0<r<1     // radius and center scaling
	//r=saturate(pow(abs(r), Power) * Center);

	float r = (length( Pw ) - Center) / (Radius - Center);  //0<r<1     // radius and center scaling
	r = 1-r;
	r = saturate(pow(abs(r), Power));

	float4x4 rz, rzn;
	float4x4 rx1, rx2, rx3, ry1, ry2, ry3;
	float time, b;

	b = Timer;

	rz = RotMatZ(b);			//Bra function
	rzn = transpose(rz);		//Ket function

	rx1 = RotMatX(r * pi * spinorSpanX1);
	ry1 = RotMatY(r * pi * spinorSpanY1);
	rx2 = RotMatX(r * pi * spinorSpanX2);
	ry2 = RotMatY(r * pi * spinorSpanY2);
	rx3 = RotMatX(r * pi * spinorSpanX3);
	ry3 = RotMatY(r * pi * spinorSpanY3);
	
	float4x4 Rotation = {
	{1,		0,		0,		0},
	{0,		1,		0,		0},
	{0,		0,		1,		0},
	{0,		0,		0,		1}};

	//GENERATED LINES

Rotation = mul(Rotation, rz);
Rotation = mul(Rotation, rx1);
Rotation = mul(Rotation, rzn);

	/////////////////////////// output stage		
	Pw = mul(Pw, Rotation);
	output.Normal = mul(Normal, Rotation);
	output.Position = mul(Pw, VpXf);
	return output;
}



/////////////////////////// pixel shaders ///////////////////////////

float4 PS_P( PS_IN input ) : SV_Target
{
	return input.Color;
}

float4 PS_G( PS_IN input ) : SV_Target
{
	float4 color = input.Color;
	float3 nV = input.Normal;
	float3 Lv = {0,0,1};
	float c = 14.0 * (input.UV.x - 0.5);  // 0..1  ->  -1..1
	c = saturate(pow((c * c), 0.3));
	float i = 0.5 * (1 + dot(nV, Lv));   //-1..1  ->  0..1
	i = saturate(0.2 + pow(i, 2));
	color = color * i * c;
	color = float4(color.xyz, opacity);
	return color;
}

/////////////////////////// techniques ///////////////////////////

technique10 RenderParticle
{
	pass P0
	{
		SetGeometryShader( 0 );
		SetVertexShader( CompileShader( vs_4_0,  VS_P() ) );
		SetPixelShader( CompileShader( ps_4_0, PS_P() ) );
	}
}

technique10 RenderGeom
{
	pass P0
	{
		SetGeometryShader( 0 );
		SetVertexShader( CompileShader( vs_4_0,  VS_G() ) );
		SetPixelShader( CompileShader( ps_4_0, PS_G() ) );
	}
}

technique10 RenderTrails
{
	pass P0
	{
		SetGeometryShader( 0 );
		SetVertexShader( CompileShader( vs_4_0,  VS_T() ) );
		SetPixelShader( CompileShader( ps_4_0, PS_P() ) );
	}
}